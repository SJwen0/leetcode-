### leetcode困难题

[2003. 每棵子树内缺失的最小基因值](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/)

题目大意：以0为根的树，每棵树的节点有一个基因值，范围为[1, ${10}^5$]，并且基因值互不相同。求每颗以i为根的子树中的最小未出现的基因值。

解决办法：只有基因值1的祖先路径上他的最小未出现的基因值才会大于1，其他所有节点都是不存在基因值1的。所以我们就只需要找到基因值为1的点，然后向上遍历，每次把子树遍历一遍，把基因值加入集合中。没有遍历到的点基因值只能为1.

```python3
class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        n = len(parents)
        ans = [1] * n
        #如果这颗树不含基因值1 那么直接返回
        if 1 not in nums:
            return ans
		#创建一个集合
        vis = set()
        #使用列表存储树
        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[parents[i]].append(i)
        
        def dfs(x : int) -> None:
            vis.add(nums[x])
            for son in g[x]:
                #这里就可以防止重复遍历过的子树
                if nums[son] not in vis:
                    dfs(son)
        mex = 2
        node = nums.index(1)
        #parents[0] = -1
        while node >= 0:
            dfs(node)
            #每次遍历完之后要更新答案 因为可能有新的元素加入
            while mex in vis:
                mex += 1 # += 1 不要 ++mex
            ans[node] = mex
            node = parents[node] 
        return ans

        
```

