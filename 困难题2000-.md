## leetcode困难题

### [2003. 每棵子树内缺失的最小基因值](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/)

题目大意：以0为根的树，每棵树的节点有一个基因值，范围为[1, ${10}^5$]，并且基因值互不相同。求每颗以i为根的子树中的最小未出现的基因值。

解决办法：只有基因值1的祖先路径上他的最小未出现的基因值才会大于1，其他所有节点都是不存在基因值1的。所以我们就只需要找到基因值为1的点，然后向上遍历，每次把子树遍历一遍，把基因值加入集合中。没有遍历到的点基因值只能为1.

```python3
class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        n = len(parents)
        ans = [1] * n
        #如果这颗树不含基因值1 那么直接返回
        if 1 not in nums:
            return ans
		#创建一个集合
        vis = set()
        #使用列表存储树
        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[parents[i]].append(i)
        
        def dfs(x : int) -> None:
            vis.add(nums[x])
            for son in g[x]:
                #这里就可以防止重复遍历过的子树
                if nums[son] not in vis:
                    dfs(son)
        mex = 2
        node = nums.index(1)
        #parents[0] = -1
        while node >= 0:
            dfs(node)
            #每次遍历完之后要更新答案 因为可能有新的元素加入
            while mex in vis:
                mex += 1 # += 1 不要 ++mex
            ans[node] = mex
            node = parents[node] 
        return ans

        
```

### [2009. 使数组连续的最少操作数](https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/)

题目大意：给一个nums数组，你可以进行以下操作：`nums` 中 **任意** 一个元素替换成 **任意** 整数。然后求进行最少的操作次数，使得数组满足：1.所有元素各不相同。2.最大元素-最小元素=len(nums)-1。

解决办法：使用滑动窗口，且窗口大小固定为len(nums)（就是r-l+1==n n个连续元素），使得窗口内不个不同的元素最多，那么把其他元素变到窗口内元素的次数就会越少。最少操作次数=n - max(窗口内不同的元素个数)，所以我们还可以先对nums数组去重 然后排序进行滑动窗口。

```python3
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        #之前数组的长度
        n = len(nums)
        #去重+排序
        nums = sorted(set(nums))
        #去重后数组的长度
        m = len(nums)
        j = 0
        #最大次数为n-1
        ans = n - 1
        for i in range(0, m):
            #滑动窗口最大值和最小值 < n 那就是满足条件  所以我们其实是枚举最小值
            while (j < m and nums[j] - nums[i] < n):
                j += 1
            ans = min(ans, n - j + i)
        return ans
```

### [2014. 重复 K 次的最长子序列](https://leetcode.cn/problems/longest-subsequence-repeated-k-times/)

题目大意：给定一个长度为n的字符串s和一个整数k。请你找出字符串 `s` 中 **重复** `k` 次的 **最长子序列** 。如果存在多个满足条件的子序列，则返回字典序最大的那个。如果不存在这样的字串，则返回空串。

解决办法：乍一看很难 但是题目有说$2 <= n < min(2001,k * 8)$也就是说 最多存在7个字符满足个数至少为k的条件， 那么这样的话我们就可以暴力枚举 从7个元素中选1个，2个，...，7个 且进行全排列这样的时间复杂度是不高的。然后就使用双指针的方法看是否存在，这样时间复杂度是O(n * ($A_7^1 + A_7^2 + ... + A_7^7)$))的 那么时间复杂度是能过的。

```python3
class Solution: 
    def isSubSequnece(self, seq: str, s:str) -> bool:
        it = iter(s)
        #它不是在问 “c 是否在 s 的所有字符里”，而是在问 “c 是否在迭代器 it 剩下的元素里”。
        return all(c in it for c in seq)
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        cnt = Counter(s)
        a = [ch for ch, freq in cnt.items() for _ in range(freq // k)]
        a.sort(reverse = True)
        for i in range(len(a), 0, -1):
            for perm in permutations(a, i):
                #用 .join() 前面的字符串（这里是空字符串 ''）作为“胶水”粘合起来，形成一个新字符串
                seq = ''.join(perm)
                if self.isSubSequnece(k * seq, s):
                    return seq
        return ''
                
```

### [2019. 解出数学表达式的学生分数](https://leetcode.cn/problems/the-score-of-students-solving-math-expression/)

题目大意：给一个字符串s，只包含数字 `0-9` ，加法运算符 `'+'` 和乘法运算符 `'*'`，这个字符串表示一个 **合法** 的只含有 **个位数**数字的数学表达式（比方说 `3+5*2`）。再给一个长度为n的整数数组answers，表示每位学生提交的答案。你的任务是给answer数组按照以下规则打分：1.如果学生的答案等于表达式的正确结果，将得到5分。2.如果答案由 **一处或多处错误的运算顺序** 计算得到，那么这位学生能得到 `2` 分。3.否则0分。

解决办法：使用区间dp。dp[l]\[r]：区间[l,r]经过任意计算所得出的答案集合。对于正确答案，我们可以使用eval()直接求出，注意字符串的长度一定是奇数,因为数字个数=字符个数+1.

```python3
class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        #直接能算出答案
        target = eval(s)
        n = len(s)
        dp = defaultdict(lambda: defaultdict(set))
        #初始化答案
        for i in range(0, n, 2):
            dp[i][i].add(int(s[i]))
        #枚举的span只能奇数 偶数必定有一个运算符没运算
        for span in range(3, n + 1, 2):
            #n-1-span+1+1
            for l in range(0, n - span + 1, 2):
                r = l + span - 1
                for mid in range(l + 1, r, 2):
                    v1 = dp[l][mid - 1]
                    v2 = dp[mid + 1][r]
                    for a in v1:
                        for b in v2:
                            if s[mid] == '*' and a * b <= 1000:
                                dp[l][r].add(a * b)
                            if s[mid] == '+' and a + b <= 1000:
                                dp[l][r].add(a + b)
        ans = 0
        for x in answers:
            if x == target:
                ans += 5
            elif x in dp[0][n - 1]:
                ans += 2
        return ans 
```

